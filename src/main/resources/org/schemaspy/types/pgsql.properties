#
# see http://schemaspy.org/dbtypes.html
# for configuration / customization details
#
dbms=PostgreSQL
description=Before Version 11
connectionSpec=jdbc:postgresql://<hostOptionalPort>/<db>
host=host where database resides with optional port
port=port database is listening on
db=database name

driver=org.postgresql.Driver

# Sample path to the postgresql drivers.
# Use -dp to override.
driverPath=/org/schemaspy/drivers/postgresql-9.4.1208.jre6.jar

# return text that represents a specific :view / :schema
selectViewSql=select definition as view_definition from pg_views where viewname = :table UNION select definition as view_definition from pg_matviews where matviewname = :table
viewTypes=VIEW,MATERIALIZED VIEW

selectSchemasSql=SELECT nspname AS schema_name, pg_catalog.obj_description(oid, 'pg_namespace') AS schema_comment FROM pg_catalog.pg_namespace where nspname = :schema
selectCatalogsSql=SELECT datname AS catalog_name, pg_catalog.obj_description(datlastsysoid, 'pg_database') AS catalog_comment FROM pg_catalog.pg_database WHERE datname = :catalog ;
# selectTablesSql=select table_schema as table_catalog, null as table_schema, table_name, table_comment, table_rows from information_schema.tables where table_schema=:schema and table_type='BASE TABLE'

selectRoutinesSql=select \
r.routine_name || '(' || oidvectortypes(p.proargtypes) || ')' as routine_name, \
case when p.proisagg then 'AGGREGATE' else 'FUNCTION' end as routine_type, \
case when p.proretset then 'SETOF ' else '' end || case when r.data_type = 'USER-DEFINED' then r.type_udt_name else r.data_type end as dtd_identifier, \
r.external_language as routine_body,\
r.routine_definition, \
r.sql_data_access, \
r.security_type, \
r.is_deterministic, \
d.description as routine_comment \
from information_schema.routines r \
left join pg_namespace ns on r.routine_schema = ns.nspname \
left join pg_proc p on r.specific_name = p.proname || '_' || p.oid \
left join pg_description d on d.objoid = p.oid \
where r.routine_schema = :schema
selectRoutineParametersSql=select \
r.routine_name || '(' || oidvectortypes(pp.proargtypes) || ')' as specific_name, \
coalesce(p.parameter_name, '$' || p.ordinal_position) as parameter_name, \
p.data_type as dtd_identifier, \
p.parameter_mode \
from information_schema.parameters p \
left join information_schema.routines r on r.specific_name = p.specific_name \
left join pg_proc pp on r.specific_name = pp.proname || '_' || pp.oid \
where p.specific_schema = :schema \
order by p.specific_name, p.ordinal_position

selectCheckConstraintsSql=select tc.table_name, tc.constraint_name, cc.check_clause as text from information_schema.check_constraints cc left join information_schema.table_constraints tc on tc.constraint_catalog = cc.constraint_catalog and tc.constraint_schema = cc.constraint_schema and tc.constraint_name = cc.constraint_name where cc.constraint_name not like '%not_null' and tc.constraint_schema = :schema

selectTypesSql=with typedesc AS (select * \
 from (values (cast('b' as "char"), 'Base'), \
 (cast('c' as "char"), 'Composite'), \
 (cast('d' as "char"), 'Domain'), \
 (cast('e' as "char"), 'Enum'), \
 (cast('p' as "char"), 'Pseudo-type')) AS t(typtype, typedesc)), \
 all_types AS (SELECT n.nspname as schema, \
 pg_catalog.format_type(t.oid, NULL) as typename, \
 coalesce(pg_catalog.obj_description(t.oid, 'pg_type'), '') as typedescription, \
 typtype, \
 typedesc as typeoftype, \
 t.oid as typeoid, \
 t.typrelid, \
 t.typbasetype, \
 t.typtypmod, \
 t.typnotnull, \
 typnamespace, \
 t.typdefault, \
 t.typinput, \
 t.typoutput \
 FROM pg_catalog.pg_type t \
 join typedesc using (typtype) \
 join pg_catalog.pg_namespace n ON n.oid = t.typnamespace \
 WHERE (t.typrelid = 0 OR \
 (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid)) \
 AND NOT EXISTS(SELECT 1 \
 FROM pg_catalog.pg_type el \
 WHERE el.oid = t.typelem \
 AND el.typarray = t.oid) \
 AND n.nspname = :schema), \
 bases as (select typeoftype, \
 schema, \
 typename, \
 typedescription, \
 'in=' || typinput || '; out=' || typoutput as definition \
 from all_types \
 where typtype = 'b'), \
 composites_attributes as (SELECT typeoftype, \
 schema, \
 typename, \
 typedescription, \
 a.attname, \
 a.attnum, \
 pg_catalog.format_type(a.atttypid, a.atttypmod) as atttype, \
 pg_catalog.col_description(a.attrelid, a.attnum) as attdescription, \
 (SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid, true) \
 FROM pg_catalog.pg_attrdef d \
 WHERE d.adrelid = a.attrelid \
 AND d.adnum = a.attnum \
 AND a.atthasdef) AS default_value, \
 a.attnotnull, \
 (SELECT c.collname \
 FROM pg_catalog.pg_collation c, \
 pg_catalog.pg_type t \
 WHERE c.oid = a.attcollation \
 AND t.oid = a.atttypid \
 AND a.attcollation <> t.typcollation) AS attcollation, \
 a.attidentity \
 FROM pg_catalog.pg_attribute a \
 JOIN all_types t \
 ON a.attrelid = t.typrelid \
 JOIN pg_catalog.pg_namespace n \
 ON n.oid = t.typnamespace \
 WHERE t.typtype = 'c' \
 AND a.attnum > 0 \
 AND NOT a.attisdropped \
 order by schema, typename, attnum), \
 composites AS (select typeoftype, \
 schema, \
 typename, \
 typedescription, \
 string_agg(attname || E'\t' || atttype || \
 case when attnotnull then E'\tNOT NULL' else '' end || \
 case \
 when default_value is not null then E'\tDEFAULT ' || default_value \
 else '' end || \
 case \
 when attdescription is not null then E'\t-- ' || attdescription || '' \
 else '' end, \
 E'\n') \
 as definition \
 from composites_attributes \
 group by typeoftype, schema, typename, typedescription), \
 domains AS (SELECT typeoftype, \
 schema, \
 typename, \
 typedescription, \
 pg_catalog.format_type(t.typbasetype, t.typtypmod) || \
 CASE WHEN t.typnotnull THEN ' NOT NULL' ELSE '' END || \
 CASE \
 WHEN t.typdefault IS NOT NULL THEN E'\nDEFAULT ' || t.typdefault \
 ELSE '' END || \
 CASE WHEN length(check_def) > 0 then E'\n' || check_def else '' end \
 as definition \
 FROM all_types t \
 JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace \
 join lateral pg_catalog.array_to_string(ARRAY( \
 SELECT pg_catalog.pg_get_constraintdef(r.oid, true) \
 FROM pg_catalog.pg_constraint r \
 WHERE t.typeoid = r.contypid \
 ), ' ') AS check_def(check_def) on true \
 WHERE t.typtype = 'd'), \
 enums as (select typeoftype, \
 schema, \
 typename, \
 typedescription, \
 '{' || string_agg(enumlabel, ', ') || '}' as definition \
 from all_types \
 join (select enumtypid as typeoid, enumlabel from pg_enum order by 1, 2) pg_enum_ordered \
 using (typeoid) \
 group by typeoftype, schema, typename, typedescription), \
 pseudos as (select typeoftype, \
 schema, \
 typename, \
 typedescription, \
 '' as definition \
 from all_types \
 where typtype = 'p'), \
 all_formated_types AS (select * \
 from bases \
 union all \
 select * \
 from composites \
 union all \
 select * \
 from domains \
 union all \
 select * \
 from enums \
 union all \
 select * \
 from pseudos) \
select typeoftype as "type_of_type", \
 schema, \
 null as catalog, \
 typename as name, \
 typedescription as description, \
 definition \
from all_formated_types

selectSequencesSql=SELECT seqs.sequence_name, seqs.start_value, seqs.increment FROM information_schema.sequences seqs WHERE seqs.sequence_schema = :schema

selectRowCountSql=SELECT reltuples AS row_count from pg_class WHERE oid = CAST(:schema || '.' || :table AS regclass)